
println! â€“ formatting + var args
println!("User {} logged in", user_id);

Why macro?
Variable arguments
Compile-time format checking

2ï¸âƒ£ vec! â€“ ergonomic heap allocation
let v = vec![1, 2, 3];

Expands to

let mut v = Vec::new();
v.push(1); v.push(2); v.push(3);

3ï¸âƒ£ assert! / assert_eq! â€“ testing & safety
assert!(x > 0);
assert_eq!(a, b);

Why macro?
Captures expressions
Prints values on failure

4ï¸âƒ£ dbg! â€“ debug without moving values
let y = dbg!(x + 1);


Why macro?
Prints file + line + expression
Returns value

5ï¸âƒ£ matches! â€“ readable pattern matching
if matches!(msg, Some(_)) {}


Why macro?
Cleaner than match

6ï¸âƒ£ cfg! / #[cfg] â€“ platform-specific code
#[cfg(target_os = "linux")]
fn linux_only() {}


Used in
Cross-platform libraries

7ï¸âƒ£ include_str! â€“ embed assets
static CONFIG: &str = include_str!("config.toml");


Used in
CLI tools
Embedded systems

8ï¸âƒ£ thread_local! â€“ per-thread state
thread_local! {
    static COUNTER: std::cell::Cell<u32> = std::cell::Cell::new(0);
}


Used in
Logging
Metrics

9ï¸âƒ£ lazy_static! / once_cell â€“ global init
use once_cell::sync::Lazy;

static DB: Lazy<Db> = Lazy::new(|| Db::connect());


Why macro originally?

Safe global initialization

ğŸ”Ÿ #[derive(...)] â€“ remove boilerplate
#[derive(Debug, Clone, Serialize, Deserialize)]
struct User {
    id: u32,
}


Used everywhere

Structs

Enums

APIs

1ï¸âƒ£1ï¸âƒ£ #[tokio::main] â€“ async runtime
#[tokio::main]
async fn main() {
    run().await;
}

Expands to
Runtime setup
Executor start

1ï¸âƒ£2ï¸âƒ£ serde macros â€“ serialization
#[derive(Serialize, Deserialize)]
struct Config {
    port: u16,
}


Why macro?

Generates fast, type-safe code

1ï¸âƒ£3ï¸âƒ£ log macros â€“ logging facade
log::info!("Server started");
log::error!("Failed: {}", err);


Why macro?

Zero-cost if disabled

1ï¸âƒ£4ï¸âƒ£ sqlx::query! â€“ compile-time SQL checks
sqlx::query!("SELECT id FROM users WHERE id = ?", id);


Why macro?

SQL validated at compile time

1ï¸âƒ£5ï¸âƒ£ bitflags! â€“ low-level flags
bitflags! {
    struct Flags: u32 {
        const A = 0b0001;
        const B = 0b0010;
    }
}


Used in

OS

Networking

Drivers

ğŸ§  Pattern summary
Formatting        â†’ println!
Collections       â†’ vec!
Safety            â†’ assert!
Debugging         â†’ dbg!
Config / platform â†’ cfg!
Globals           â†’ Lazy / lazy_static!
Async             â†’ #[tokio::main]
Serialization     â†’ serde derives
Logging           â†’ log::info!
DB                â†’ sqlx::query!
Low-level         â†’ bitflags!

Rule of thumb
Macros appear where:
- syntax is needed
- code must be generated
- performance must be zero-cost

Want next?

ğŸ”§ macro_rules! deep dive

ğŸ§¬ procedural macro internals

ğŸ— write your own real macro

ğŸ” macro expansion walkthrough

Say one word and we go deeper ğŸš€

give me macros in readme.md 

Hereâ€™s a ready-to-copy README.md focused on Rust macros, real-world usage, concise explanations, and examples ğŸ‘‡

# ğŸ¦€ Rust Macros â€“ Practical Guide

Macros in Rust generate code at **compile time**.  
They are used when **functions or generics are not enough**.

---

## ğŸ“Œ Why Macros Exist
- Variable arguments
- Code generation
- Zero-cost abstractions
- Custom syntax (DSLs)
- Compile-time checks

---

## ğŸ§± Types of Macros

### 1ï¸âƒ£ Function-like macros
```rust
println!("Hello {}", name);
vec![1, 2, 3];

2ï¸âƒ£ Derive macros
#[derive(Debug, Clone)]
struct User;

3ï¸âƒ£ Attribute macros
#[tokio::main]
async fn main() {}

ğŸ”¥ Common Built-in Macros
Output & Debug
println!("text");
eprintln!("error");
dbg!(value);

Formatting
format!("Hello {}", name);
format_args!("x={}", x);

Assertions
assert!(x > 0);
assert_eq!(a, b);
assert_ne!(a, b);
debug_assert!(x > 0);

Panic & Placeholders
panic!("fatal");
todo!();
unimplemented!();
unreachable!();

ğŸ“¦ Collections
vec![1, 2, 3];

ğŸ§  Pattern Matching
matches!(x, Some(_));

ğŸ§© Compile-Time Macros
include!("file.rs");
include_str!("data.txt");
include_bytes!("bin.dat");

concat!("a", "b");
env!("HOME");
option_env!("HOME");

ğŸ“ Source Info
file!();
line!();
column!();
module_path!();

âš™ï¸ Conditional Compilation
cfg!(unix);

#[cfg(feature = "foo")]
fn feature_code() {}

ğŸ§ª Testing
#[test]
fn test_add() {
    assert_eq!(2 + 2, 4);
}

ğŸ§µ Thread & Globals
thread_local! {
    static COUNT: std::cell::Cell<u32> = std::cell::Cell::new(0);
}

ğŸ— Real-World Macros (Crates)
Logging
log::info!("started");
log::error!("failed");

Serialization (serde)
#[derive(Serialize, Deserialize)]
struct Config {
    port: u16,
}

Async Runtime
#[tokio::main]
async fn main() {}

Database (SQL checked at compile-time)
sqlx::query!("SELECT id FROM users");

Flags (low-level)
bitflags::bitflags! {
    struct Flags: u32 {
        const A = 0b0001;
        const B = 0b0010;
    }
}

ğŸ›  macro_rules! (Declarative Macro)
macro_rules! say_hello {
    () => {
        println!("Hello");
    };
}

say_hello!();
