cfg conditions in Rust, including advanced logical combinations.

# Rust `cfg` ‚Äì Complete Reference (README)

This document lists **all practical `#[cfg(...)]` conditions** used in Rust for
platforms, builds, tests, features, and advanced logic.

---

## 1Ô∏è‚É£ Core Build / Mode Flags

```rust
#[cfg(test)]                  // cargo test
#[cfg(debug_assertions)]       // debug build
#[cfg(not(debug_assertions))]  // release build

2Ô∏è‚É£ Test-Specific Flags
#[cfg(test)]          // unit & integration tests
#[cfg(doctest)]       // documentation tests
#[cfg(bench)]         // benchmarks (cargo bench)

3Ô∏è‚É£ Feature Flags (Cargo.toml)
#[cfg(feature = "foo")]
#[cfg(not(feature = "foo"))]


Run:

cargo test --features foo

4Ô∏è‚É£ Operating System
Generic
#[cfg(unix)]
#[cfg(windows)]

Specific OS
#[cfg(target_os = "linux")]
#[cfg(target_os = "windows")]
#[cfg(target_os = "macos")]
#[cfg(target_os = "android")]
#[cfg(target_os = "ios")]
#[cfg(target_os = "freebsd")]

5Ô∏è‚É£ Architecture
#[cfg(target_arch = "x86")]
#[cfg(target_arch = "x86_64")]
#[cfg(target_arch = "arm")]
#[cfg(target_arch = "aarch64")]
#[cfg(target_arch = "wasm32")]

6Ô∏è‚É£ Environment / ABI
#[cfg(target_env = "gnu")]
#[cfg(target_env = "msvc")]
#[cfg(target_env = "musl")]

#[cfg(target_abi = "eabi")]
#[cfg(target_abi = "eabihf")]

7Ô∏è‚É£ Pointer Width
#[cfg(target_pointer_width = "32")]
#[cfg(target_pointer_width = "64")]

8Ô∏è‚É£ Endianness
#[cfg(target_endian = "little")]
#[cfg(target_endian = "big")]

9Ô∏è‚É£ Atomic Support
#[cfg(target_has_atomic = "8")]
#[cfg(target_has_atomic = "16")]
#[cfg(target_has_atomic = "32")]
#[cfg(target_has_atomic = "64")]
#[cfg(target_has_atomic = "ptr")]

üîü Panic Strategy
#[cfg(panic = "unwind")]
#[cfg(panic = "abort")]

1Ô∏è‚É£1Ô∏è‚É£ Compiler / Language
#[cfg(rustfmt)]
#[cfg(clippy)]

1Ô∏è‚É£2Ô∏è‚É£ Logical Operators (ADVANCED)
all
#[cfg(all(test, unix))]
#[cfg(all(test, target_arch = "x86_64"))]

any
#[cfg(any(test, feature = "testing"))]

not
#[cfg(not(windows))]

Combined (Real-World)
#[cfg(all(test, not(feature = "integration")))]

#[cfg(all(test, unix, target_arch = "x86_64"))]

#[cfg(any(
    all(unix, feature = "epoll"),
    all(windows, feature = "iocp")
))]

1Ô∏è‚É£3Ô∏è‚É£ cfg!() Macro (Boolean Check)
if cfg!(test) {
    println!("Running tests");
}


‚ö† Code is compiled, but condition is evaluated at compile time.

1Ô∏è‚É£4Ô∏è‚É£ cfg_attr (Conditional Attributes)
#[cfg_attr(debug_assertions, derive(Debug))]
#[cfg_attr(test, allow(dead_code))]

1Ô∏è‚É£5Ô∏è‚É£ Test-Only Helpers Pattern
#[cfg(any(test, feature = "test-utils"))]
mod test_helpers;

1Ô∏è‚É£6Ô∏è‚É£ Visibility for Tests
#[cfg(test)]
use super::*;

#[cfg(test)]
pub(crate) fn helper() {}

üß† Summary Cheat List
